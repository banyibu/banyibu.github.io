<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++学习笔记第九章_顺序容器 | 致良知，事上练</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="顺序容器概述各种顺序容器，在向容器添加或从容器删除元素的代价、非顺序访问容器中元素的代价是有不同折中的。">
<meta name="keywords" content="计算机语言,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记第九章_顺序容器">
<meta property="og:url" content="http://banyibu.com/2018/08/18/C-学习笔记第九章-顺序容器/index.html">
<meta property="og:site_name" content="致良知，事上练">
<meta property="og:description" content="顺序容器概述各种顺序容器，在向容器添加或从容器删除元素的代价、非顺序访问容器中元素的代价是有不同折中的。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12985001-fe0e572bb4d47b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-08-19T13:06:15.879Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++学习笔记第九章_顺序容器">
<meta name="twitter:description" content="顺序容器概述各种顺序容器，在向容器添加或从容器删除元素的代价、非顺序访问容器中元素的代价是有不同折中的。">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/12985001-fe0e572bb4d47b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="致良知，事上练" type="application/atom+xml">
  
  
    <link rel="icon" href="images/1260.gif">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://upload-images.jianshu.io/upload_images/12985001-ffd8bc90edb9f3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <h2 class="author">般一不</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>31</strong><br>文章</div></a>
      <a href="/categories"><div><strong>19</strong><br>分类</div></a>
      <a href="/tags"><div><strong>20</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
          <a href="/sponsor" title="Sponsor">
            <li>投喂</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-C-学习笔记第九章-顺序容器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/18/C-学习笔记第九章-顺序容器/" class="article-date">
  <time class="post-time" datetime="2018-08-18T14:52:32.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">18</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++学习笔记第九章_顺序容器
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>,<a class="article-category-link" href="/categories/计算机基础/计算机语言/">计算机语言</a>,<a class="article-category-link" href="/categories/计算机基础/计算机语言/C-Primer/">C++ Primer</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h3><p>各种顺序容器，在向容器添加或从容器删除元素的代价、非顺序访问容器中元素的代价是有不同折中的。<br><a id="more"></a><br>| 容器类型|描述|<br>|-|-|<br>|vector|可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素很慢|<br>|deque|双端队列，支持快速随机访问，在头尾位置插入元素很快|<br>|list|双向链表，支持双向顺序访问，在list中任何位置插入元素都很快|<br>|forward_list|单链表。只支持单向顺序访问。在链表任何位置进行插入或删除元素都很快|<br>|array|固定大小数组。支持快速随机访问。不能添加或删除元素|<br>|string|与vector相似的容器，但专门用来保存字符。在尾部插入或删除比较快|</p>
<h3 id="容器库概述"><a href="#容器库概述" class="headerlink" title="容器库概述"></a>容器库概述</h3><p>一些容器操作对容器类型有特殊的要求，这时候，我们若定义了不支持特殊要求类型的容器，使用时，要注意不要使用相应的操作。<br>例如，容器支持提供一个整数作为容器大小。但这个操作需要使用默认构造函数，容容器类型没有默认构造函数，则需要我们提供一个额外的初始化器。<br>容器操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器</td>
<td>const_iterator</td>
<td></td>
</tr>
<tr>
<td>size_type</td>
<td>足够保存容器类型最大可能容器的大学</td>
<td>difference_type</td>
<td>保存两个迭代器之间的距离</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
<td>reference</td>
<td>元素的左值类型：同value_type&amp;</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的const左值类型</td>
<td>C c</td>
<td>默认构造函数，构造空容器</td>
</tr>
<tr>
<td>C c1(c2)</td>
<td>构造c2的拷贝c1</td>
<td>C c(b,e)</td>
<td>构造c将迭代器b和e指定的范围内的元素拷贝到c（array不支持）</td>
</tr>
<tr>
<td>C c{a,b,c……}</td>
<td>列表初始化c</td>
<td>c1=c2</td>
<td>赋值</td>
</tr>
<tr>
<td>c1={a,b,c……}</td>
<td>将c1中的元素替换为c2中的元素（不适用于array）</td>
<td>a.swap(b)</td>
<td>交换a，b</td>
</tr>
<tr>
<td>swap(a,b)</td>
<td>与a.swap()等价</td>
<td>c.size()</td>
<td>c中元素的数目（不支持forward_list)</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>c可保存的最大元素数目</td>
<td>c.empty()</td>
<td>若c中存储了元素，返回false，否则返回true</td>
</tr>
<tr>
<td>添加和删除元素</td>
<td>array不适用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>c.insert(args)</td>
<td>将args中的元素拷贝进c</td>
<td>c.emplace(inits)</td>
<td>使用inits构造c中的一个元素</td>
</tr>
<tr>
<td>c.erase(args)</td>
<td>删除args中的元素</td>
<td>c.clear()</td>
<td>删除c中的所有元素，返回void</td>
</tr>
<tr>
<td>== !=</td>
<td>所有容器都支持</td>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>关系运算符，无序关联容器不支持</td>
</tr>
<tr>
<td>c.begin(),c.end()</td>
<td>指向c的首元素和尾后元素的迭代器</td>
<td>c.cbegin(),c.cend()</td>
<td>返回const_iterator</td>
</tr>
<tr>
<td></td>
<td>反向容器的额外成员（不支持forword_list）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>按逆序寻址元素的迭代器</td>
<td>const_reverse_iterator</td>
<td>不能修改元素的逆序容器</td>
</tr>
<tr>
<td>c.rbegin()</td>
<td>c.rend()</td>
<td>c.crbegin()</td>
<td>c.crend()</td>
</tr>
</tbody>
</table>
<p>容器定义和初始化中，只有顺序容器支持如下初始化方式，C seq(n),seq包含n个元素，这些元素进行值初始化；C seq(n,t)，seq包含n个初始值为t的元素。<br>创建一个容器为另一个容器的拷贝，两个容器类型及元素类型必须匹配。而若用迭代器参数拷贝一个范围，则只需容器元素类型相容即可。<br>只有顺序容器的构造函数才接受大小参数，关联容器不支持。且顺序容器元素类型若不支持默认初始化，则必须为在元素大小之外提供一个初始值。<br>array具有固定大小，初始化时需要指定容器大小。例如：array&lt;\int ,10&gt;。一个默认构造的array是非空的，它包含了与其大小一样多的元素，这些元素都被默认初始化了。<br>array拷贝时，容器类型和大小都必须相同。且array不支持迭代器范围初始化。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>seq.assign(b,e)</td>
<td>将seq中的元素替换为迭代器b和e所表示范围的元素，迭代器b和e不能指向seq中的元素</td>
<td>seq.assign(il)</td>
<td>将seq中的元素替换为初始化列表il中的元素</td>
</tr>
<tr>
<td>seq.assign(n,t)</td>
<td>将seq中的元素替换为n个值为t的元素</td>
<td></td>
</tr>
</tbody>
</table>
<p>注意：assign允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign不适用于array。<br>swap交互操作，只交换了两个容器的内部数据结构。容器元素并为交换，所以速度很快。且交换后，指针不会改变。<br>除了array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。<br>容器大小操作：size、max_size、empty，其中forward_list支持max_size和empty但是不支持size。<br>只有当容器的元素类型定义了相应的比较运算符时，我们才可以用到关系运算符来比较两个容器。</p>
<h3 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h3><p><strong>向顺序容器添加元素</strong><br>向容器中添加元素：forward_list有自己专有版本的insert和emplace；forward_list不支持push_back和emplace_back。vector和string不支持push_front和emplace_front。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t), c.emplace_back(args)</td>
<td>在c的尾部创建一个值为t或由args创建的元素，返回void</td>
<td>c.push_front(t), c.emplace_front(args)</td>
<td>在c的头部创建一个值为t或由args创建的元素。返回void</td>
</tr>
<tr>
<td>c.insert(p,t), c.emplace(p,args)</td>
<td>在迭代器p指向的元素之前创建一个值为t的元素或由args创建的元素，返回指向新添加的元素的迭代器</td>
<td>c.insert(p,n,t)</td>
<td>在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器；若n为零，则返回p</td>
</tr>
<tr>
<td>c.insert(p,b,e)</td>
<td>将迭代器b和e指定范围的内容插入到p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，返回p</td>
<td>c.insert(p,il)</td>
<td>il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p</td>
</tr>
</tbody>
</table>
<p>向vector、string、deque插入元素会使得所有指向容器的迭代器、指针和引用失效。<br>除了array、forward_list之外，每个顺序容器都支持push_back。<br>list、forward_list和deque容器还支持名为push_front的类似操作。<br>vector、deque、list、string都支持insert成员。forward_list有自己定义的特殊版本的insert。注意，将元素插入到vector、deque和string中发任何位置都是合法的。然而可能耗时很长。<br>emplace_front、emplace、emplace_back,这三个操作构造元素而不是拷贝，会用传入的参数调用容器元素类型的构造函数，在容器中直接构造元素。<br><strong>访问元素</strong><br>包括array在内的每个顺序容器都有一个front成员函数，除forward_list之外的所有顺序容器都有一个back成员函数。这两个元素分别返回首元素和尾元素的引用。<br>注意在调用front和back，以及解引用迭代器之前，要确保容器非空。<br>在顺序容器中访问元素的操作<br>at和下标操作只适用于string、vector、deque、array<br>back不适用于forward_list。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>首元素的引用</td>
<td>c.front()</td>
<td>尾元素的引用</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回c中下标为n的引用，n是一个无符号整数，若下标越界，则函数未定义</td>
<td>c.at(n)</td>
<td>返回c中下标为n的引用，若下标越界，则抛出一个out_of_range异常</td>
</tr>
</tbody>
</table>
<p>访问成员函数返回的都是引用。<br><strong>删除元素</strong><br>forward_list有自己特殊版本的erase，且其不支持pop_back; vector和string不支持pop_front。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.pop_back()</td>
<td>删除c中尾元素，若c为空，函数未定义，返回void</td>
<td>c.pop_front()</td>
<td>……</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器所指的元素，返回迭代器指向被删除元素之后的元素，若p是尾后迭代器，函数未定义</td>
<td>c.erase(b,e)</td>
<td>删除迭代器b和e所指范围内的元素。返回一个迭代器指向最后一个被删除元素之后的元素，若e是尾后迭代器，则返回尾后迭代器</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除c中所有元素，返回void</td>
<td></td>
</tr>
</tbody>
</table>
<p>删除deque首位位置之外的任何元素都会使所有迭代器、指针和引用失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。<br>删除元素时，必须确保其时存在的。<br><strong>forward_list特殊操作</strong><br>删除或添加都是在给定元素之后操作的。<br>forward_list中插入或删除元素的操作</p>
<p>| 操作|解释|操作|解释|<br>|lst.before_begin()|指向链表首前不存在的元素的迭代器。|lst.cbefore_begin()|返回const_iterator|<br>|lst.insert_after(p,t), lst.insert_after(p,n,t), lst.insert_after(p,b,e), lst.insert_after(p,il)|在迭代器p之后的位置插入元素，t是一个对象，n是数量，b，e表示范围的一对迭代器，il表示一个花括号列表。如果范围为空，返回p，如果p为尾后迭代器，函数未定义|emplace_after(p,args)|使用args在p指定的位置之后构造一个元素，若p是尾后迭代器则函数未定义|<br>|lst.erase_after(p), lst.erase(b,e)|删除p指向的位置之后的一个元素，或删除b之后直到e之间的元素。返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，返回尾后迭代器。若p指向尾后元素，则函数行为未定义|||<br>在forward_list中添加或删除元素时，我们需要关注要删除的元素和其前驱元素。<br><strong>改变容器大小</strong><br>我们可以使用resize来增大或缩小容器，array不支持。<br>c.resize(n): 调整c的大小为n个元素。若n&lt;\c.size(),则多出是元素被删除。若要添加，则对新元素进行值初始化。<br>c.resize(n,t):挑战c的大小。任何新添加的元素都初始化为t。<br>如果resize缩小容器，则指向被删除元素的迭代器、引用或指针都会失效；对vector、string或deque进行resize可能导致迭代器、指针和引用失效。<br><strong>容器操作可能导致迭代器失效</strong><br>对deque，如果首位插入元素，迭代器会失效，但是指向元素的引用和指针不会失效。<br>对于list和forward_list，指向容器的指针、迭代器和引用都有效。<br>注意，在添加或删除容器元素的操作中，不要保存尾后元素。</p>
<h3 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h3><p>管理容量的成员函数：shrink_to_fit只适用于vector、string、deque；capacity和reserve只适用于vector和string</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>shrink_to_fit()</td>
<td>将capacity()减少到与size()相同大小</td>
<td>c.capacity()</td>
<td>不重新分配内存的话，c可以保存多少元素</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>分配至少能容纳n个元素的内存空间</td>
<td></td>
</tr>
</tbody>
</table>
<p>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。<br>reserve只改变容器的容量，而resize则只改变容器中的元素数量。<br>注意：调用shrink_to_fit()，只是发出一个请求，未必会退回多余的内存空间。</p>
<h3 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h3><p><strong>构造string的其他方法</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp,n)</td>
<td>s包含cp指向的数组中前n个字符的拷贝。此数组应该至少包含n个字符</td>
<td>string s(s2,pos2)</td>
<td>s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;s2.size()，函数行为未定义</td>
</tr>
<tr>
<td>string s(s2,pos2,len2)</td>
<td>s是string s2从pos2开始len2个字符从拷贝。最多拷贝len2个字符</td>
<td></td>
</tr>
</tbody>
</table>
<p>substr(pos, count);substr(pos),返回字符串的子串。注意带字符数量count的函数，最多返回count个字符。<br><strong>改变string的其他方法</strong><br>修改string的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos,args)</td>
<td>在pos之前插入args指定的字符。pos可以是一个下标或迭代器。接受下标的版本返回一个指向s的引用，接受迭代器的返回指向第一个插入字符的迭代器。</td>
<td>s.erase(pos,len)</td>
<td>删除从位置pos开始的len个字符。如果len被省略，则删除pos之后的所有字符，返回一个指向s的引用</td>
</tr>
<tr>
<td>s.assign(args)</td>
<td>将s中的字符替换为args指定的字符。返回一个指向s的引用</td>
<td>s.append(args)</td>
<td>将args追加到s。返回一个指向s的引用</td>
</tr>
<tr>
<td>s.replace(range, args)</td>
<td>删除s中范围range内的字符，替换为args指定的字符。range或是一个下标和长度或是一对指向s的迭代器。返回一个指向s的引用</td>
<td></td>
</tr>
</tbody>
</table>
<p>上面，args可以是：str; str,pos,len; cp,len; cp; n,c; b,e; 初始化列表。append和assign可以使用任何一种形式。replace和insert依赖于range和pos是如何指定的。<br><img src="https://upload-images.jianshu.io/upload_images/12985001-fe0e572bb4d47b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在replace和insert中args指定方式"><br><strong>string的搜索操作</strong><br>string共有6个搜索函数，每个有四个重载版本，每个搜索操作返回一个string::size_type值，表示匹配发送位置的下标。如果搜索失败，返回一个名为string::npos的静态成员。<br>string搜索操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>查找s中args第一次出现的位置</td>
<td>s.rfind(args)</td>
<td>查找s中args最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>在s中查找args中任何一个字符第一次出现的位置</td>
<td>s.find_last_of(args)</td>
<td>在s中查找args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>查找s中第一个不在args中的字符</td>
<td>s.find_last_not_of(args)</td>
<td>在s中查找最后一个不在args中的字符</td>
</tr>
</tbody>
</table>
<p>args必须是下列形式之一：<br>c,pos 从s中位置pos开始查找字符c。pos默认为0； s2,pos 从s中位置pos开始查找字符串s2。pos默认是0；cp,pos 从s中位置pos位置查找cp指向的以空字符结尾的C风格字符串。pos默认为0；cp,pos,n 从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值；<br><strong>compare函数</strong><br>s.compare的几种参数形式<br>s2；pos1,n1,s2; pos1,n1,pos2,n2; cp; pos1,n1,cp; pos1,n1,cp,n2;<br><strong>数值转换</strong><br>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值无法用任何类型来表示，则抛出out_of_range异常。<br>string和数值之间的转换</p>
<p>| to_string(val)|一组重载函数，返回val的string表示。|stoi(s,p,b), stol(s,p,b),stoul(s,p,b),stoll(s,p,b),stoull(s,p,b)|返回s的起始子串的数值，返回类型是int、long、unsigned long、long long、unsigned long long。b表示转换所用的基数，默认值为10。p是size_t指针，用来保存s中第一个非数值字符的下标，p默认为零，即，函数不保存下标|<br>|stof(s,p), stod(s,p), stold(s,p)|返回s的起始子串的数值，返回值类型分别是float、double或long double。参数p作用与前面一样|||</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>三个顺序容器适配器：stack、queue、priority_queue。<br>适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器。<br>一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。<br>所有容器适配器都支持的操作和类型：</p>
<table>
<thead>
<tr>
<th>操作或类型</th>
<th>解释</th>
<th>操作或类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>一种类型，足以保存当前类型的最大对象的大小</td>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>container_type</td>
<td>实现适配器的底层容器类型</td>
<td>A a;</td>
<td>创建一个名为a的容器适配器</td>
</tr>
<tr>
<td>A a(c)</td>
<td>创建容器适配器a，带有容器c的一个拷贝</td>
<td>关系运算符</td>
<td>每个容器适配器都支持所有的关系运算符，且返回其底层容器的比较结果</td>
</tr>
<tr>
<td>a.empty()</td>
<td>若a包含任何元素，返回false，否则返回true</td>
<td>a.size()</td>
<td>返回a中的元素数目</td>
</tr>
<tr>
<td>swap(a,b), a.swap(b)</td>
<td>交互a，b。a和b必须有相同的类型，包括底层容器类型也必须相同</td>
<td></td>
</tr>
</tbody>
</table>
<p>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。<br>stack&lt;\string, vector&lt;\string&gt;&gt; str_stk;<br>注意，所有容器适配器都需要其底层容器类型可以添加和删除元素，且都支持访问尾部元素的功能。<br><strong>栈适配器</strong><br>栈默认基于deque实现，也可以是list或vector，栈操作还包括：<br>| 操作|解释|操作|解释|<br>|-|-|-|-|<br>|s.pop()|删除栈顶元素，但不返回给元素|s.push(item), s.emplace(args)|创建一个新元素压入栈，该元素通过拷贝或移动item而来，或者由args构造|<br>|s.top()|返回栈顶元素，但不弹出栈顶元素|||<br><strong>队列适配器</strong><br>queue和priority_queue适配器定义在queue头文件中。<br>queue默认基于deque实现，priority_queue默认基于vector实现。queue也可以基于list，priority_queue也可以用deque实现。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.pop()</td>
<td>删除queue的首元素或priority_queue的最高优先级的元素，但不返回该元素</td>
<td>q.front(), q.back()</td>
<td>返回首元素或尾元素，但不删除。只适用于queue</td>
</tr>
<tr>
<td>q.top()</td>
<td>返回最高优先级元素，但不能删除，只适用于priority_queue</td>
<td>q.push(item), q.emplace(args)</td>
<td>在queue末尾或priority_queue中恰当的位置创建一个其值为item的元素或由args构造一个</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://banyibu.com/2018/08/18/C-学习笔记第九章-顺序容器/" data-id="cjl59abu4000a7ov71n3z3q4y" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机语言/">计算机语言</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/19/C-学习笔记第十章-泛型算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          C++学习笔记第十章_泛型算法
        
      </div>
    </a>
  
  
    <a href="/2018/08/18/C-学习笔记第八章-IO库/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">C++学习笔记第八章_IO库</div>
    </a>
  
</nav>

  
</article>






  <div id="comments" class="comments">
  	<div id="uyan_frame"></div>
  </div>
	<section class="livere" id="comments">
<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNzc5NS8xNDMyNg==">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</section>
	


</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">致良知，事上练</h1>
    <h2 class="blog-subtitle">偏爱精神世界的更新换代，日日思之，日日求突破。</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
          <a href="/sponsor" title="Sponsor">
            <li>投喂</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://upload-images.jianshu.io/upload_images/12985001-ffd8bc90edb9f3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <h2 class="author">般一不</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>31</strong><br>文章</div></a>
      <a href="/categories"><div><strong>19</strong><br>分类</div></a>
      <a href="/tags"><div><strong>20</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/banyibu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="https://dadavision.cn" target="_blank" title="Dadavision">
          Dadavision
        </a>
      
        <a class="hvr-bounce-in" href="https://www.resultlv.com" target="_blank" title="Rwsultlv">
          Rwsultlv
        </a>
      
    </div>
  </div>
</div>



  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 般一不<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Ban Yibu</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/about" title="" class="menuItem">关于</a>
          
            <a href="/sponsor" title="" class="menuItem">打赏</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>