<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++学习笔记第三部分C++标准库，13-16章总结 | 致良知，事上练</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="概述">
<meta name="keywords" content="计算机语言,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记第三部分C++标准库，13-16章总结">
<meta property="og:url" content="http://banyibu.com/2018/08/27/C-学习笔记第三部分C-标准库，13-16章总结/index.html">
<meta property="og:site_name" content="致良知，事上练">
<meta property="og:description" content="概述">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-29T15:00:09.719Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++学习笔记第三部分C++标准库，13-16章总结">
<meta name="twitter:description" content="概述">
  
    <link rel="alternate" href="/atom.xml" title="致良知，事上练" type="application/atom+xml">
  
  
    <link rel="icon" href="images/1260.gif">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://upload-images.jianshu.io/upload_images/12985001-ffd8bc90edb9f3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <h2 class="author">般一不</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>36</strong><br>文章</div></a>
      <a href="/categories"><div><strong>19</strong><br>分类</div></a>
      <a href="/tags"><div><strong>20</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
          <a href="/sponsor" title="Sponsor">
            <li>投喂</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-C-学习笔记第三部分C-标准库，13-16章总结" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/C-学习笔记第三部分C-标准库，13-16章总结/" class="article-date">
  <time class="post-time" datetime="2018-08-27T14:07:38.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++学习笔记第三部分C++标准库，13-16章总结
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>,<a class="article-category-link" href="/categories/计算机基础/计算机语言/">计算机语言</a>,<a class="article-category-link" href="/categories/计算机基础/计算机语言/C-Primer/">C++ Primer</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><a id="more"></a>
<h3 id="第十三章，拷贝控制"><a href="#第十三章，拷贝控制" class="headerlink" title="第十三章，拷贝控制"></a>第十三章，拷贝控制</h3><p><strong>拷贝、赋值与销毁</strong><br>合成拷贝构造函数，会将其参数的成员逐个拷贝到正在创建的对象中。<br>拷贝初始化发生的情况：</p>
<ol>
<li>使用=定义变量时发生；</li>
<li>将一个对象作为实参传递给非引用类型的形参；</li>
<li>返回类型为非引用类型的函数返回一个对象；</li>
<li>从花括号列表初始化一个数组中的元素或一个聚合类中的成员。<br>explicit构造函数不能隐式的使用，只能显示的使用。<br>需要析构函数的类也需要拷贝和赋值操作。<br>需要拷贝操作的类也需要赋值操作，反之亦然。<br>使用=default，显示的要求编译器生成合成版本。其默认是内联的，要不想让它内联，则在类内申明，类外使用=default定义。<br>阻止拷贝：定义删除的函数=delete。其中=delete必须出现在函数第一次声明的时候。我们可以对任意函数指定为=delete。析构函数不能是删除的成员。<br><strong>拷贝控制和资源管理</strong><br>赋值运算符：</li>
<li>要正确处理自赋值的情况；</li>
<li>大多数赋值运算符都组合了析构函数和拷贝构造函数的工作。<br><strong>交换操作</strong><br>swap，如果没有自定义的swap函数，编译器在需要使用该函数时，会调用标准库定义的swap。<br>拷贝并交换的操作定义赋值运算符是异常安全的。<br><strong>拷贝控制示例</strong><br><strong>动态内存管理类</strong><br>allocator<t> construct() destory() deallocate()<br>移动构造函数和std::move<br><strong>对象移动</strong><br>拷贝后就要被销毁的对象、不能拷贝的对象可以移动；<br>标准库容器、string和shared_ptr类既支持拷贝也支持移动。IO类和unique_ptr类可以移动但是不能拷贝。<br>右值引用只能绑定到一个将要销毁的对象上。&amp;&amp;<br>变量是左值，即便是一个右值引用类型，其也是左值。<br>move：我们可以销毁一个移后源对象，也可以为其赋值，但是不能使用它了。<br>不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。<br>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。<br>定义了移动操作的类，也必须定义自己的拷贝操作，否则，这些成员默认地被定义为删除的。<br>移动右值，拷贝左值，但是如果没有移动构造函数，右值也被拷贝。<br>移动迭代器：make_move_iterator函数，其解引用得到的是一个右值引用。<br>注意移动操作，必须保证移后源对象没有其他用户使用。<br>右值和左值引用成员函数：避免为右值赋值，可以添加引用限定符。引用限定符跟在形参列表后const之后，表示this是左值或右值的属性。<br>引用限定符也可以区分函数重载。<br>当定义成员函数时，可以定义多个版本的同一函数，但是只要其中一个函数加了引用限定符，则其余具有相同参数列表的函数也要添加引用限定符。<h3 id="第十四章，操作重载与类型转换"><a href="#第十四章，操作重载与类型转换" class="headerlink" title="第十四章，操作重载与类型转换"></a>第十四章，操作重载与类型转换</h3><strong>基本概念</strong><br>除了重载的函数调用运算符operator()之外，其他的重载运算都不能含有默认实参。<br>对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。<br>可被重载的运算符：+ - * / % ^ &amp; | ~ ! , = &lt; &gt; &lt;= &gt;= ++ -\- &lt;&lt; &gt;&gt; == != &amp;&amp; || += -= /= %= ^= &amp;= |= *= &lt;&lt;= &gt;&gt;= [] () -&gt; -&gt;* new new[] delete delete[]<br>不能被重载的运算符：:: .* . ?:<br>运算符的重载版本，其内置运算符的求值顺序和求值属性在重载版本中不会被保留。<br>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</t></li>
<li>= [] () -&gt;，应该被重载为成员函数；</li>
<li>复合赋值也应该定义为成员，但并非必须；</li>
<li>改变对象状态的运算符或与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员；</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，他们一般一个是普通成员。<br><strong>输入和输出运算符</strong><br>输入输出运算符必须是非成员函数。<br>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。<br><strong>算术和关系运算符</strong><br>如果同时定义了算数运算符和相关的复合赋值运算符，则应该使用复合赋值运算符来实现算术运算符。相等和不等也同理定义。<br>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时包含了==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。<br><strong>赋值运算符</strong><br>我们可以重载赋值运算符，但是无论其形参的类型是什么，赋值运算符都必须定义为成员函数。<br><strong>下标运算符</strong><br>下标运算符必须是成员函数。通常定义一个返回普通引用的版本和一个返回常量引用的版本。<br><strong>递增和递减运算符</strong><br>递增和递减运算符通常应该被定义成类的成员，且递增递减前置和后置版本都应该定义。<br>后置递增递减运算符需要一个额外的int参数。后置递增递减应该返回一个一个值，而前置应该返回对象的引用。<br><strong>成员访问运算符</strong><br>解引用运算符和箭头运算符。<br>箭头运算符通常必须是类的成员，解引用运算符通常也应该是类的成员，尽管并非必须如此。<br>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。<br><strong>函数调用运算符</strong><br>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。<br>函数对象常常作为泛型算法的实参。<br>lambda是函数对象，当我们编写一个lambda后，编译器将该表达式翻译成一个未命名类的对象。<br>lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数通常要视其捕获的值而定。<br>标准库定义的函数对象，他们都被定义在functional头文件中：plus<type> minus<type> multiplies<type> divides<type> modulus<type> negate<type> equal_to<type> not_equal_to<type> greater<type> greater_equal<type> less<type> less_equal<type> logical_and<type> logical_or<type> logical_not<type><br>C++中的可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。<br>每个lambda有它自己唯一的类类型，函数及函数指针的类型则由其返回值和参数类型决定。<br>调用形式、标准库function类型。function是一个模版，定义对象时需要我们传入可调用对象的调用形式作为额外信息。<br>使用function，只要调用形式相同，则都可以保存到相同的function对象中。<br>重载的同名函数不能直接以函数名存储到function对象中，否则，会产出二义性。我们可以通过一个函数指针将其间接的保存到function对象中。<br><strong>重载、类型转换与运算符</strong><br>转换构造函数和类型转换运算符共同定义了类类型转换，这样的转换也称为用户定义的类型转换。<br>类型转换运算符一般不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成const成员。<br>一个类型转换运算符必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const的。<br>其形式：<code>operator type() const;</code><br>显示的类型转换运算符：在转换运算符前面加explicit。可以使用static_cast来显示调用。对于作为表达式条件，则显示的类型转换也会被执行。<br>避免二义性的类型转换，通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。<br>当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。<br>当同时定义了类型转换运算符及重载运算符时特别容易产生二义性：以下规则需在意：</type></type></type></type></type></type></type></type></type></type></type></type></type></type></type></li>
<li>不要令两个类执行相同的类型转换；</li>
<li>避免转换目标是内置算数类型的类型转换，特别是定义多个算数类型转换：<br>除了显示的向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能的限制那些“显然正确”的非显示构造函数。<br>重载函数与转换构造函数：如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好。<br>在调用重载函数时，如果需要额外的标准转换，则该转换的级别只有等当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所有的用户定义的类型转换不止一个，则该调用具有二义性。<br>表达式中运算符的候选集即包括成员函数，也包括非成员函数。<br>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。<h3 id="第十五章，面向对象程序设计"><a href="#第十五章，面向对象程序设计" class="headerlink" title="第十五章，面向对象程序设计"></a>第十五章，面向对象程序设计</h3><strong>OPP：概述</strong><br>数据抽象、继承和动态绑定、基类、派生类、虚函数、类派生列表、访问说明符、virtual、override<br>当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定。<br><strong>定义基类和派生类</strong><br>基类通常都应该定义一个虚析构函数，即使函数不执行任何操作也是如此。<br>虚函数的关键字virtual只能出现在类内部的声明语句之前，而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在其派生类中依然是虚函数。<br>注意：override关键字放在const以及引用限定符后面。<br>派生类到基类的类型转换。<br>每个类控制它自己的成员初始化，也即，派生类中的基类部分由基类构造函数初始化。<br>派生类的作用域嵌套在基类的作用域之内。<br>继承与静态成员：如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。<br>派生类的声明，不需要包含继承列表。<br>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。<br>直接基类、间接基类<br>防止继承的发生：final加在类名之后。<br>智能指针类也支持从派生类向基类的类型转换。<br>静态类型、动态类型<br>派生类赋值给基类类型，会进行切掉处理，即忽略派生类所属的数据成员，只处理基类部分。<br><strong>虚函数</strong><br>具有继承关系的多个类型称为多态性。<br>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该函数，也只有在这种情况下对象的动态类型才有可能与静态类型不同。<br>一旦某个函数被声明为虚函数，则所有派生类中它都是虚函数。覆盖虚函数时，形参类型必须一致，其返回类型也必须与基类中的虚函数一致，除非返回的事类本身的指针或引用。<br>成员函数中的final跟在const或引用限定符后面。<br>虚函数也可以由默认实参，如果某次函数调用中使用了默认实参，则该实参值由本次调用的静态类型决定。<br>可以使用作用域运算符强制改变虚函数机制，使调用函数属于特定的类版本。通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的机制。<br><strong>抽象基类</strong><br>纯虚函数、抽象基类<br>=0；加在类内的虚函数声明的后面。也可以在类外为纯虚函数提供函数体。（意义呢？？？）<br>不能创建抽象类的对象。<br><strong>访问控制与继承</strong><br>每个类控制着其成员对于派生类来说是否可访问。<br>派生类的成员或友元只能通过派生类的对象访问基类的受保护成员。派生访问说明符对于派生类成员及友元能否访问其直接基类的成员没有什么影响。只是控制派生类用户对基类成员的访问权限。派生访问说明符还可以控制继承自派生类的新类的访问权限。<br>派生类向基类转换的可访问性，假定D继承自B：</li>
<li>只有当D公有的继承B时，用户代码才可以使用派生类向基类的转换；否则用户代码不能使用该转换；</li>
<li>不论D以什么方式继承B，D的成员和友元都可以使用派生类向基类的转换；</li>
<li>如果D继承B是公有的或受保护的，则D的派生类的成员和友元都可以使用D向B的转换；反之，如果D继承B是私有的，则不能使用。<br>友元关系不能继承，每个类负责各自成员的访问权限。<br>改变个别成员的可访问性：可以使用using声明对派生类继承的某个名字改变访问级别。using声明的名字的访问级别由using之前的访问说明符来决定。派生类只可以为那些它可以访问到的名字提供using申明。<br>默认的继承保护级别：class私有，struct公有。<br><strong>继承中类的作用域</strong><br>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。<br>派生类的成员将隐藏同名的基类成员。但是可以通过作用域运算符来使用隐藏的成员。<br>名字查找先于类型查找：声明在内层作用域中的函数并不会重载声明在外层作用域中的函数。同样可以使用作用域运算符来使用被隐藏的名字。<br>覆盖重载的函数：为派生类提供一条using语句，对要重载的函数名进行声明，这样就将基类中的重载函数添加到了派生类的作用域中。<br><strong>构造函数和拷贝控制</strong><br>如果基类的析构函数不是虚函数，则delete一个指向派生类的对象的基类指针，将产生未定义的行为。<br>虚析构函数会阻止编译器合成默认移动操作。<br>合成拷贝控制与继承：<br>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。<br>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或移动基类部分，必须在派生类的构造函数初始值列表中显示的使用基类的拷贝或移动构造函数。<br>派生类的赋值运算符也必须显示的为基类部分赋值。<br>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。<br>继承的构造函数：using申明，可以将直接基类的构造函数继承过来，但是类不能继承默认、拷贝和移动构造函数。<br>一个基类构造函数含有默认参数，派生类继承该构造函数不会继承参数，而会获得多个继承的构造函数。如果派生类自己定义的构造函数的参数列表和继承来的构造函数相同，则派生类自定义的版本会替换继承而来的版本。<br><strong>容器和继承</strong><br>容器和存在继承关系的类型无法兼容。<br>在容器中存放（智能）指针而非对象。<br>我们也可以把一个派生类的智能指针转换成基类的智能指针。<br>隐藏指针、模拟拷贝<br><strong>文本查询程序再探</strong></li>
</ol>
<h3 id="第十六章，模版与泛型编程"><a href="#第十六章，模版与泛型编程" class="headerlink" title="第十六章，模版与泛型编程"></a>第十六章，模版与泛型编程</h3><p><strong>定义模版</strong><br>OOP能处理类型在程序运行之前都未知的情况；而泛型编程可以处理编译时就获知类型了。<br>一个模版就是一个创建类或函数的蓝图或者说是公式。<br>函数模版、模版参数列表中模版参数、模板实参、模板的实例、模版类型参数、非类型模版参数<br>在模版定义中，模版参数列表不能为空。<br>一个非类型参数可以是一个整数，或者是一个指向对象或函数类型的指针或引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。<br>函数模版可以申明为inline或constexpr的。这两个关键字放在模版参数列表之后，函数返回值之前。<br>模版程序应该尽量减少对实参类型的要求。<br>函数模版和类模版成员的定义通常放在头文件中。<br>保证传递给模版的实参支持模版所要求的操作，以及这些操作在模版中能正确工作，是调用者的责任。<br>实例化类模版：显式模版实参；<br>一个类模板的每个实例都形成一个独立的类。<br>在模板作用域中引用模版类型。<br>类模版的成员函数：可以定义在内部，隐式内联；也可以定义在外部，定义在外部时需要以template和模版参数列表开始。<br>类模版成员函数的实例化，只有当用到成员函数时，才进行相应的初始化。<br>在一个类模版的作用域中，我们可以直接使用模版名而不用指定模版实参。<br>类模版和友元：当一个类包含一个友元声明时，类和友元各自是否是模版是互无关系的。<br>为了让所有实例成为友元，友元的声明中必须使用与模板本身不同的模版参数。<br>可以将模版类型参数声明为友元。<br>模版类型别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef Blob&lt;string&gt; StrBlob;</span><br><span class="line">template&lt;typename T&gt; using twin=pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;double&gt; area;</span><br><span class="line">template&lt;typename T&gt; using partNo=pair&lt;T, unsigned&gt;;</span><br><span class="line">partNo&lt;string&gt; books;</span><br></pre></td></tr></table></figure></p>
<p>类模版的static成员：<br>一个实例化有一个静态成员：定义：<code>template &lt;typename T&gt; size_t Foo&lt;T&gt;::ctr=0;</code><br>一个模版参数名的可用范围是在其声明之后，至模版声明或定义之前。模版内不能重用模版参数名。一个模版名在一个特定模版参数列表中只能出现一次。<br>模版声明时，其模版参数名字不必与定义时的一致。<br>一个特定文件所需要的所有模版的声明通常一起放在文件中开始位置，出现于任何使用这些模版的代码之前。<br>使用类的类型成员：<code>typename T::value_type ;//解释为T的类型成员而不是T的静态成员</code><br>默认模版实参：与函数默认实参一样，对于一个模版参数，只有当它右侧的所有参数都有默认实参时，它才可以由默认实参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename F=less&lt;T&gt;&gt;</span><br><span class="line">int compare(const T &amp;v1, const T &amp;v2, F f=F())&#123;……;&#125;</span><br></pre></td></tr></table></figure></p>
<p>类模版与默认实参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T=int&gt; class Numbers&#123;……&#125;;</span><br><span class="line">Numbers&lt;&gt; average; //空&lt;&gt;表示我们希望使用默认类型</span><br></pre></td></tr></table></figure></p>
<p>成员模版：成员模版不能是虚函数。<br>类模版的成员模版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; class Blob&#123;</span><br><span class="line">	template &lt;typename It&gt; Blob(It b, It e);</span><br><span class="line">&#125;;</span><br><span class="line">//类外定义类模版成员模版</span><br><span class="line">template&lt;typename T&gt; //类的类型参数</span><br><span class="line">template&lt;typename It&gt; //构造函数的类型参数</span><br><span class="line">    Blob&lt;T&gt;::Blob(It b, It e): data(std::make_shared&lt;std::vector&lt;T&gt;(b,e))&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例化控制：显示实例化来避免相同实例在文件中多次出现造成的开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern template class Blob&lt;string&gt;; //声明</span><br><span class="line">template int compare(const int&amp;, const int&amp;);//定义</span><br></pre></td></tr></table></figure></p>
<p>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。实例化定义会实例化所有成员。<br>在一个类模版实例化定义中，所有类型必须能用于模版的所有成员函数。<br>在运行时绑定删除器shared_ptr，在编译时绑定删除器unique_ptr<br><strong>模版实参推断</strong><br>类型转换与模版类型参数：能在模版函数调用中使用的转换规则有：const转换、数组或函数指针转换。<br>算术转换、派生类向基类的转换以及用户定义的转换都不能应用于函数模版。<br>如果函数参数不是模版参数，则对实参进行正常的类型转换。<br>函数模版显式实参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2, typename T3&gt;</span><br><span class="line">T1 sum(T2, T3);</span><br><span class="line">//显式实参指定</span><br><span class="line">auto val3 = sum&lt;long long&gt;(i, lng);//long long sum(int, long);</span><br></pre></td></tr></table></figure></p>
<p>正常的类型转换会应用于显式指定的实参。<br>位置返回类型与类型转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename It&gt;</span><br><span class="line">auto fcn(It beg, It end)-&gt;decltype(*beg)&#123; //返回引用</span><br><span class="line">	……;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型转换的标准库模版类，定义在type_traits头文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename It&gt;</span><br><span class="line">auto fcn2(It beg, It end)-&gt; typename remove_reference&lt;decltype(*beg)&gt;::type&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>remove_reference add_const add_lvalue_reference add_reference add_rvalue_reference remove_pointer add_pointer make_signed make_unsigned remove_extent remove_all_extents<br>函数指针和实参推断：当我们用一个函数模版初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型推断模版实参。<br>当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模版参数，能唯一确定其类型或值。<br>模版参数推断和引用：引用折叠和右值引用参数 X&amp; &amp;、X&amp;&amp; &amp;都折叠成类型X&amp;；X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;。<br>引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。<br>右值引用常用于两种情况：模板转发实参或模板被重载。<br>std::remove的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123;</span><br><span class="line">	return static_cast&lt;typename remove_reference&lt;T&gt;&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从一个左值static_cast到一个右值是允许的。<br>转发：如果一个函数参数是指向模板类型参数的右值引用，它对应的实参的const属性和左值/右值属性将得到保持。<br>std::forward保持类型信息，它和move一样，被定义在utility文件中。<br>当用于一个指向模版参数类型的右值引用函数参数时，forward会保持参数类型的所有细节。<code>std::forward&lt;T&gt;</code>将返回指向T的右值引用。<br><strong>重载与模版</strong><br>函数模版可以被一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。<br>当有多个重载模板对一个调用提供同样好的匹配时，应该选择最特例化的版本。<br>对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非目标版本。<br>如果使用了一个忘记声明的函数，代码将会编译失败。但对于重载函数模板的函数而言，编译器可以会实例化一个并非我们需要的版本。<br><strong>可变参数模版</strong><br>一个可变参数模板就是一个可接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包。<br>模板参数包：零个或多个模板参数；<br>函数参数包：零个或多个函数参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Args是一个目标参数包；rest是一个函数参数包</span><br><span class="line">//Args表示零个或多个模板类型参数</span><br><span class="line">//rest表示零个或多个函数参数</span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void foo(const T &amp;t, const Args&amp;... rest);</span><br></pre></td></tr></table></figure></p>
<p>当我们需要知道包中含有多少元素时，可以使用sizeof…运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename...Args&gt; void g(Args...args)&#123;</span><br><span class="line">	sizeof...(Args);//类型参数的数目  </span><br><span class="line">	sizeof...(args); //函数参数的数目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写可变参数函数模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">ostream &amp;print(ostream &amp;os, const T &amp;t)&#123;</span><br><span class="line">	return os&lt;&lt;t; //包中最后一个元素不打印分隔符</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)&#123; //扩展Args</span><br><span class="line">	os&lt;&lt;t&lt;&lt;&quot;,&quot;; //打印第一个实参</span><br><span class="line">	return print(os, rest...); //递归调用，打印其他实参； 扩展rest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。佛则，可变参数版本会无限递归。<br>包括展：我们在模式右边放置一个…来触发扩展。<br>更复杂的包扩展模式，扩展中的模式会独立地应用于包中的每个元素。<code>print(os, debug_rep(rest)...);</code><br>转发参数包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class... Args&gt;</span><br><span class="line">inline</span><br><span class="line">void StrVec::emplace_back(Args&amp;&amp;...args)&#123;</span><br><span class="line">	chk_n_alloc(); //如果需要的话，重新分配StrVec内存空间</span><br><span class="line">	alloc.construct(first_free++, std::forward&lt;Args&gt;(args)...); //同时对Args和args扩展</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>模版特例化</strong><br>当我们不能或不希望使用模板版本时，可以定义类或函数模板的一个特例化版本。<br>一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">int compare(const char* const &amp;p1,const char* const &amp;p2)&#123;</span><br><span class="line">	return strcmp(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个特例化版本本质上是一个实例，而非函数名的一个重载版本。所以特例化不会影响函数匹配。<br>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何可使用模板实例化的代码之前，特例化版本的声明也必须在作用域中。<br>模板和其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。<br>类模板特例化：<br>类模板部分特例化的本质是一个类模板。我们不能部分特例化函数模板。<br>remove_reference类型是通过一系列的特例化版本来完成的。<br>特例化成员而不是类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; struct Foo&#123;</span><br><span class="line">	Foo(const T &amp;t = T()):mem(t)&#123;&#125;</span><br><span class="line">	void Bar()&#123;……;&#125;</span><br><span class="line">	T mem;</span><br><span class="line">	……;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt;</span><br><span class="line">void Foo&lt;int&gt;::Bar()&#123; //特例化Foo&lt;int&gt;的成员Bar</span><br><span class="line">	……;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://banyibu.com/2018/08/27/C-学习笔记第三部分C-标准库，13-16章总结/" data-id="cjlhgk0st002cg8v7q3gv8f46" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机语言/">计算机语言</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/30/C-学习笔记第十七章-标准库特殊设施/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          C++学习笔记第十七章_标准库特殊设施
        
      </div>
    </a>
  
  
    <a href="/2018/08/26/C-学习笔记第十六章—-模版与泛型编程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">C++学习笔记第十六章—_模版与泛型编程</div>
    </a>
  
</nav>

  
</article>






  <div id="comments" class="comments">
  	<div id="uyan_frame"></div>
  </div>
	<section class="livere" id="comments">
<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNzc5NS8xNDMyNg==">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</section>
	


</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">致良知，事上练</h1>
    <h2 class="blog-subtitle">偏爱精神世界的更新换代，日日思之，日日求突破。</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
          <a href="/sponsor" title="Sponsor">
            <li>投喂</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://upload-images.jianshu.io/upload_images/12985001-ffd8bc90edb9f3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    <h2 class="author">般一不</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>36</strong><br>文章</div></a>
      <a href="/categories"><div><strong>19</strong><br>分类</div></a>
      <a href="/tags"><div><strong>20</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/banyibu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="https://dadavision.cn" target="_blank" title="Dadavision">
          Dadavision
        </a>
      
        <a class="hvr-bounce-in" href="https://www.resultlv.com" target="_blank" title="Rwsultlv">
          Rwsultlv
        </a>
      
    </div>
  </div>
</div>



  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 般一不<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Ban Yibu</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/about" title="" class="menuItem">关于</a>
          
            <a href="/sponsor" title="" class="menuItem">打赏</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>